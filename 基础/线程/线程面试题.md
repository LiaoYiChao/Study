## 线程面试题

### 什么是线程安全

[原作者 - 原文章](https://mp.weixin.qq.com/s/WDeewsvWUEBIuabvVVhweA)

#### 概述：

- **线程安全并不是指线程的安全，而是指内存的安全。**
    - 为什么如此说，是和操作系统有关，目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程，这是由操作系统保障的。
    - 每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。
        - 比如：某个线程把数据处理到一半，因为中途有其他事情，或者累，就去忙去了，然后回来准备接着之前进行处理，却发现数据已经被修改了，不是自己离开时的样子了，该种很有可能被其他线程修改了。（生活案例：马路属于公共地区，你将自己私有的1千块丢在上面，然后回家了，然后睡醒想回去捡，大概率会消失）因为公共区域人来人往，你放的东西在没有看管措施时，一定是不安全的。内存中的情况亦然如此。
    - **结论**：线程安全是指，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为放进去的数据，可能被别的线程”破坏“。

#### 线程安全解决方案：

##### 解决方案一：私有的东西就不该让别人知道

- 如现实中很多人会把钱藏着掖着，不会让无关的人知道，所以根本不可能扔到大马路上，因为该钱是自己的私有物品。而程序中亦如此，所以**操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问**。这也是操作系统保障的。

    - 较为常见的栈内存的变量就是**局部变量**，局部变量中的数值其他线程不能操作也不需要操作。

    - ~~~java
        void test(String a) {
            String b = a + "--";
            int a = 10;
            double sum = 0;
        }
        
        /*
          上述 b，a，sum 变量都是局部变量，这些都会被分配到线程栈内存中。
          假如现在 A线程来执行这个方法，这些变量会在A的栈内存分配。与此同时，B线程也来执行这个方法，这些变量也会在B的栈内存中分配。
          也就是说这些局部变量会在每个线程的栈内存中都分配一份，由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其他线程不知。
        */
        ~~~

- **缺点**：上述解决方案是基于“位置”，因为放的位置只有自己知道，所以东西是安全的，因此这份安全是由“位置”来保障的。在程序里就对应于方法的局部变量，局部变量之所以是安全的，就是因为其定义的 “位置” 在方法中；这样虽然安全是达到了，但其的使用范围也就被限制在这个方法里了，其他方法想用也无法使用。（实际中往往会有一个变量需要多个方法都能使用的情况，这种情况下 “位置” 就不能在方法里面了，而应该在方法外面。即从（方法的）局部变量变为（类的）成员变量。本质上是 ” 位置 “ 上发生了变化）

##### 解决方案二：不要抢，人人有份

- 上述解决方案可以看出比较明显的缺点，即 想保证 线程安全，需要将其变量 放入成员变量中，但该种情况下，其他方法无法访问其成员变量，而解决方案二争对这种情况做了一些改良：将其存在**方法的成员变量 --> 类的成员变量**；但从一个私有区域转化到公共区域，潜在的风险亦会随之而来

    - 如何保证：不要抢，人人有份，当该东西，人人皆有的时候，肯定不会发生抢的事件。因为东西多了，自然就不值钱了，另一个角度来说，也就安全了。比如大街上的共享单车等。

    - 回到程序中，要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程，这不就安全了吗，而如何做到这个，就是 ThreadLocal 类了。

        - **ThreadLocal 类概述**：

        - [ThreadLocal 类 - 原作者](https://www.jianshu.com/p/3c5d7f09dfbd)

        - 该类为一个线程内部的存储类，可以在指定线程内存存储数据，数据存储以后，只有指定线程可以得到存储数据。大致意思就是ThreadLocal 提供了线程内存存储变量的能力，这些变量不同之处在于每个线程读取的变量是对应的且相互独立的。通过 get() 和 set() 方法就可以得到当前线程对应的值。

        - ~~~java
            //set 方法
            public void set(T value) {
                  //获取当前线程
                  Thread t = Thread.currentThread();
                  //实际存储的数据结构类型
                  ThreadLocalMap map = getMap(t);
                  //如果存在map就直接set，没有则创建map并set
                  if (map != null)
                      map.set(this, value);
                  else
                      createMap(t, value);
              }
              
            //getMap方法
            ThreadLocalMap getMap(Thread t) {
                  //thred中维护了一个ThreadLocalMap
                  return t.threadLocals;
             }
             
            //createMap
            void createMap(Thread t, T firstValue) {
                  //实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals
                  t.threadLocals = new ThreadLocalMap(this, firstValue);
            }
            ~~~

            - 通过上面的代码不难看出实例化 ThreadLocalMap 时创建了一个长度为16的 Entry 数组，通过 hashCode 与 length 位运算确定出一个索引值 i，这个 i 就是被存储在 table 数组中的位置。
            - 前面讲过每个线程 Thread 持有一个 ThreadLocalMap 类型的实例 threadLocals，结合此处的构造方法可以理解成每个线程 Thread 都持有

##### 解决方案三：只能看，不能摸

- 概述：放在公共区域的东西，只是存在潜在的安全风险，并不是说一定就不安全。比如：有些东西虽然也在公共区域放着，但也十分安全。比如大街上放一个几百吨的石头雕像，就很安全，因为大家弄不动它。

    - 而回到程序中，这种情况就属于，只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了。

        - ~~~java
            class findClass {
                final Integer number = 10;
            }
            ~~~

        - 如上所示，变量前加上 final，这样所有线程都动不了它了，这就很安全。

##### 小节：以上三种解决方案，其实都是在耍花招

- 第一种：找个只有自己知道的地方藏起来，当然安全。
- 第二种：每个人都复制一份，各玩各的，互不影响，当然也安全。
- 第三种：直接规定，只能读取，禁止修改，也安全
    - 总结：上述三种方法都在 避重就轻。如何更加高效的方式，如下。

##### 最优解决方案：

###### **没有规则，那就先入为主**

- 概述：之前的三种解决方案，相较有些理想化，但现实实际中的情况是很混乱嘈杂的，没有规则的。
    - 比如：去小馆子吃饭，进门后发现只剩一个空桌子了，但这个心想先去点餐把，回来就坐这里。但点餐完后发现，桌子被他人捷足先登了。
        - 上述案例可以看出：桌子是公共区域的物品，任何人都可以坐，那就只能谁先抢到谁坐。桌子并不会因为你在人群中先看它，而让你先。
            - **解决方案**：这个就简单了，让一个人先在哪里坐着，其他人去点餐。这样当他人再来的时候，就可以理直气壮的说：不好意思，这边，我先占用了。（而这种在程序中就是 **互斥锁**）
                - 程序中，如果公共区域（堆内存）的数据，要被多个线程操作时，为了确保数据的安全性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说。
                    - 比如：一个线程来到数据前看一眼，发现锁是空闲的，没有人持有。于是它就拿到了这把锁，然后开始操作数据，干了一会活，累了，就去休息了；这时，又来了一个线程，这个线程发现锁被别人持有着，按照规定，它不能操作数据，因为它无法得到这把锁。当然，可以选择等待，或放弃转去干其他。（为什么第一个线程敢去睡觉，因为手中持有锁，其他线程不可能操作数据，所以可以睡完继续回来把数据操作完，然后在把锁释放。锁回到空闲状态，其他线程就可以在此抢这边锁。）

###### **相信世界是美好的，即使被伤害**

- 概述：回到上述案例，如果你进馆子，发现就自己一个人，先点餐与否，都无所谓，因为没有人和你抢。可以看出，都是把东西无保护的放到公共区域中，结果相差很大，说明安全问题和公共区域的环境状况有关系。
    - 回到程序中，如果把数据放到公共区域的堆内存中，但是始终都只会有一个线程，也就是单线程模型，那该数据肯定是安全的。（再者说，两个线程操作同一个数据和两百个线程操作同一个数据，该数据的安全概率是完全不一样的。线程越多，数据的安全性越低；反之线程越少，数据的安全性越高；如果只有一个线程，则数据是安全的。）
    - 而上述所要表达的就是 **CAS** ，大伙肯定有疑惑，既然锁能解决问题，用锁得了，为什么会出现个 CAS 呢。
        - **原因**：锁的获取和释放是需要花费一些代价的，如果在线程数据特别少的时候，可能根本就不会有别的线程来操作数据，此时如果还需要 获取锁 和 释放锁，则是一种浪费。
            - **解决**：争对这种 "地广人稀" 的情况，专门提出了一种方法，叫 CAS（Compare And Swap）；即在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用 CAS。
                - 执行过程：假如一个线程操作数据，干到一半，记录下当前数据状态，休息去了；醒来后打算继续接着干活，但是又担心数据可能被修改，于是就把睡觉前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明自己在睡觉期间，数据没有被人动过（当然也有可能是先被改成了其他，然后又改回来了，这个就是 ABA 问题），那就接着继续干。如果不一样，说明数据已被修改了，那之前做的操作其实都白干了，那就干脆放弃，从头来再次处理一遍。
                - **CAS 的适用范围**：适用于并发量并不高的情况，也就是数据被意外修改的可能性较小的情况。如果并发量很高，数据一定会被修改，每次都要放弃，从头再来，这样就不如直接加锁了。
                    - **ABA 问题**：睡觉前数据是5，醒来后数据还是5，但并不能肯定数据没有被修改过。可能数据先被修改成其他数后又被改回到了5，只是不知道罢了。对于该问题，很好解决，加上版本号字段即可，规定每次修改，版本号必须 +1。
        - 通过上述，相信已经发现了，CAS 其实就是 乐观锁；而之前的方案其实就是 悲观锁。乐观锁：假设我的数据不会被意外修改，如果修改了，就放弃，从头再来；悲观锁：假设我的数据一定会被修改，那就干错加锁。

### synchronized 关键字的了解

- synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
- synchronized 在 jdk1.6 之前和之后的区别
    - jdk1.6 之前，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，java 程序层面操作的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态的转换需要相对较长的时间，时间成本较高。
    - jdk1.6 之后，jdk1.6 版本对于 synchronized 大幅度的优化，所以现阶段来看，synchronized 锁效率还不错。主要对其中加入了 自旋锁，适应性自旋锁，锁消除，锁粗化，偏向锁，轻量级锁等技术来减少锁操作的开销。

### 说说自己是如何使用 synchronized 关键字的

- **修饰实例方法：**作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。
- **修饰静态方法：**相当于给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static 修饰的表示为一个静态资源，无论new 了多少份，只有一份）。所以如果一个线程A 调用一个 实例对象的 非静态 synchronized 方法，而线程B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象。**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。
- **修饰代码块：**指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
    - 总结：synchronized 关键字加到 static 静态方法和 synchronized{class} 代码块上 都是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁，尽量不要使用 synchronized{ String a }，因为 JVM 中，字符串常量池具有缓存功能。

### 请描述Synchrnoized 和 RenntrantLock 的区别

- 两者皆为可重入锁
    - **可重入锁：即自己可以再次获取自己的内部锁，不会造成死锁情况**。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取。如果为不可重入锁，就会造成死锁
- Synchronized 依赖于 JVM，而 ReentrantLock 依赖于 API
    - synchronized 是依赖于 JVM 实现的，JVM团队在 JDK1.6 对 synchronized 进行了很多优化，但这些优化是在虚拟机层面实现的，并没有直接暴露出来。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以可以通过查看其源代码，来观察其如何实现的。
- ReentrantLock 相较于 Synchronized 增加了一些高级功能
    - 等待可中断
        - **ReentrantLock 提供了 中断等待锁的线程机制**，即通过 lock.lockInterruptibly() 来实现这个机制。（也就是说 正在等待的锁 可以选择放弃当前事情，转去做其他事情）
    - 可实现公平锁
        - **ReentrantLock 可以指定公平锁还是非公平锁。而Synchronized 只能为非公平锁。**公平锁 - 先到的人先获取锁；非公平反之，谁抢到就是谁的。ReentrantLock 默认为 非公平，但通过 构造方法 传入 boolean 类型来决定是否为公平锁。
    - 可实现选择性通知（锁可以绑定多个条件）
        - Synchronized 关键字于 wait() 和 notifyAll() 方法相结合可以实现等待/通知 机制；ReentrantLock类亦能实现，不过需要借助于 Condition 接口于 newCondition() 方法。Condition 是 jdk1.5 之后才有的，具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock 对象中可以创建多个 Condition 实例（即对象监视器），**<u>线程对象可以注册在指定的 Condition 实例中，从而可以有选择性的进行线程通知，线程的调度更为灵活。如使用 notify() / notifyAll() 方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</u>，**这个功能非常重要，且是 Condition 接口默认提供。比喻看待，Synchronized 关键字就相当于整个 Lock 对象中只有一个 Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll() 方法相当于通知所有处于等待状态的线程这种效率问题，而Condition 实例的 signalAll() 方法只会唤醒注册在该 Condition 实例中的所有线程。

### Volatile 关键字

- 在jdk1.2 之前，java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 **<u>java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致</u>**。而解决这个问题，就需要将变量声明为 volatile ,该变量会指示 JVM，该变量是不稳定的，每次使用它都到主存中进行读取。说白点，volatile 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。

### Synchronized 关键字 和 Volatile 关键字的区别

- Volatile 关键字是线程同步的 轻量级实现，所以 Volatile 性能肯定比 Synchronized 关键字要好。但 volatile 关键字只能用于修饰变量，而 synchronized 可以修饰方法以及代码块。且 synchronized 在 jdk1.6 版本中进行较大优化，执行效率有显著提升，在实际开发中使用 synchronized 关键字的场景还是更多一些。
- 多线程访问 volatile 关键字不会发生阻塞，而 synchronized 关键字则可能发生阻塞。
- **volatile 关键字能保证数据的可见性，但不保证原子性，而 synchronized 两者都保证。**
- volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

### ThreadLocal

- 概述：通常情况下，创建的变量是可以被任何一个线程访问并修改的。
    - **如何实现每一个线程都拥有自己的专属本地变量**
        - JDK 提供了 ThreadLocal 类，该类主要解决的就是让每个线程绑定自己的值，可以将 ThreadLocal 类形象的比喻成存放数据的盒子，而盒子中可以存储每个线程的私有数据。如果创建了一个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本，可以使用 get() 和 set() 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免线程安全问题。

### 为什么使用线程池

- 概述
    - 池化技术现在屡见不鲜了， 线程池，数据库连接池，http连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。
    - 线程池：提供了一种限制和管理资源。每个线程池还维护了一些基本统计信息，例如已完成任务的数量。
        - **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
        - **提高响应速度**。当任务达到时，任务可以不需要的等到线程创建即可立即执行。
        - **提高线程的可管理性**。线程是较珍贵资源，如无限制创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 执行 execute() 方法和 submit() 方法的区别

- **execute()** 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
- **submit()** 方法用于提交需要返回值的任务。线程池会返回一个 futrue 类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过 futrue 的 **get()** 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 **get(long timeout, TimeUnit unit)** 方法则会阻塞当前线程一段时间后立即返回，但这个时候任务可能没有执行完。

### 如何创建线程池

- 《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，该种处理方式能让写的人更加明确线程池的运行规则，避免资源耗尽的风险。

    - 使用 Executors 创建的线程池的风险。

        - **CachedThreadPool 和 ScheduledThreadPool**：允许创建的 **线程数量** 为  Integer.MAX_VALUE，可能会创建大量线程，从而导致 OOM。
        - **FixedThreadPool 和 SingleThreadExecutor**：允许请求的 **队列长度** 为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。

    - 创建线程池

        - 方式一：通过构造方法实现

            - 使用基础构造类：**ThreadPoolExecutor**

                - 该类构造方法中参数分析：

                    - ~~~java
                            /**
                             * 用给定的初始参数创建一个新的ThreadPoolExecutor。
                             */
                            public ThreadPoolExecutor(int corePoolSize,
                                                      int maximumPoolSize,
                                                      long keepAliveTime,
                                                      TimeUnit unit,
                                                      BlockingQueue<Runnable> workQueue,
                                                      ThreadFactory threadFactory,
                                                      RejectedExecutionHandler handler) {
                                if (corePoolSize < 0 ||
                                    maximumPoolSize <= 0 ||
                                    maximumPoolSize < corePoolSize ||
                                    keepAliveTime < 0)
                                    throw new IllegalArgumentException();
                                if (workQueue == null || threadFactory == null || handler == null)
                                    throw new NullPointerException();
                                this.corePoolSize = corePoolSize;
                                this.maximumPoolSize = maximumPoolSize;
                                this.workQueue = workQueue;
                                this.keepAliveTime = unit.toNanos(keepAliveTime);
                                this.threadFactory = threadFactory;
                                this.handler = handler;
                            }
                        ~~~

                        - int **corePoolSize** - **核心线程数**（最小可以同时运行的线程数量）
                        - int **maximumPoolSize** - **最大线程数**（如核心线程数都被使用，后续任务放入 workQueue 队列中，而线程数最大变为该值同时执行 队列中的任务）
                        - long **keepAliveTime** - **空闲线程等待时间**（当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁）
                        - TimeUnit **unit** - keepAliveTime 的**时间单位**（如毫秒，秒）
                        - BlockingQueue<Runnable> **workQueue** - **缓存任务队列**（当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，任务就会被存放在队列中）
                        - ThreadFactory **threadFactory** - **创建新线程的工厂**
                        - RejectedExecutionHandler **handler** - **饱和策略**（当前运行的线程数量达到最大线程数量并且队列也已经被放满了时，对于后续进行来的线程的一些处理方式）
                            - ThreadPoolExecutor.AbortPolicy：抛出 异常来拒绝新任务的处理
                            - ThreadPoolExecutor.CallerRunsPolicy：该策略不会放弃任何任务，会以增加队列容量等方式进行。（该种策略会降低对于新任务的提交速度，影响程序的整体性能；但如果不放弃任何一个任务请求的话，可以选择该种策略）
                            - ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉 
                            - ThreadPoolExecutor.DiscardOldestPolicy：该策略会丢弃最早的未处理的任务请求。
                                - **选择方式**：使用线程池工具类创建的线程 和 使用构造函数创建的线程池如不指定 饱和策略的话，默认使用 AbortPolicy；即默认是抛出异常进行处理。

                    - 

        - 方式二：通过 Executor 框架的工具类 **Executors** 来实现 可以创建三种类型的 ThreadPoolExecutor

            - **FixedThreadPool**：该方法返回一个 固定线程数量的 线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
            - **SingleThreadExecutor**：方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
            - **CachedThreadPool**：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用（不是删除，而是永久在线程池中，待命）

    - 

### 请描述锁 的四种状态 和 升级过程

### CAS 的 ABA问题如何解决

### 请谈一下 AQS，为什么AQS 的底层是 CAS + volatile

### 请谈一下你对 volatile 的理解

### volatile 的可见性 和 禁止指令重排序是如何实现的

### CAS 是什么

### 请描述一下 对象的 创建过程

### 对象在内存中的内存布局

### DCL 单例为什么要加 volatile

### 解释一下锁的 四种状态

### Object o = new Object(); 在内存中占了多少字节

### 请描述 synchronized  和 ReentrantLock 的异同

### 聊聊你对as-if-seral 和 happens-before 语义的理解

### 了解 Threadlocal 吗，你知道 ThreadLocal 中如何解决内存泄漏问题吗

### 请描述一下锁的分类 以及jdk 中的应用

### 为什么自旋锁一定比重量级锁效率高

### 打开偏向锁是否效率一定会提升，原因是什么













## 线程面试题(其他)-分析

### Java中实现线程的方式

- 继承 Thread 类，重写其中 run 方法
- 实现 Rannable 接口
    - 无返回值
- 实现 Callable 接口
    - 有返回值
- 使用线程池

### Thread类中的 start() 和 run() 方法有什么区别

- start() 方法被用来启动新创建的线程，而且start() 内部调用了 run() 方法，run() 方法只会在原来的线程中调用，并不会新创建一个线程，start() 会在原有线程的上面新创建一个线程并使用run() 方法启动该线程。

### Runnable 和 Callable 的区别

- Runnable - jdk1.0 出现，Callable - jdk1.5 出现
- Runnable 没有返回值，Callable 拥有返回值（使用 call() 方法可以返回值和抛出异常）

### JUC中的 CyclicBarrier 和 CountDownLatch 有什么不同

- 两者都可以让一组线程 等待其他线程，但 CountDownLatch 不能重复使用，而 CyclicBarrier 可以

### Java 内存模型

- [Java内存模型理解](https://www.jianshu.com/p/15106e9c4bf3)

- Java内存模型规定 和 指引Java 程序在不同的 内存架构，CPU，操作系统之间拥有明确的行为定义，这个定义可以让程序员在并发编程思路更加清晰
    - 比如：先行发生关系确保
        - 对于同一个锁，一个解锁操作一定要发生在后发生的一个锁定操作之前；
        - 前一个 volatile 的写操作 在后一个 volatile 读操作之前。也称为 volatile 的变量规则，一个线程内的任何操作必需在这个线程的 start() 调用之后，也叫作线程启动规则。
        - 一个线程的所有操作都会在线程终止之前，线程终止规则。
        - 一个对象的终结操作必须在这个对象构建完成之后，对象终结规则。

### Java 中的 volatile 变量

- 禁止指令重排，内存中可见性
- 



